'''
Some combinatorics functions
'''

__author__ = "Ryan Anderson"

from math import *
from fractions import gcd

def allPermutations(l):
    '''Generator: generates all permutations on the given list of objects'''
    if len(l) <= 1:
        yield l
    else:
        for p in allPermutations(l[1:]):
            for i in xrange(len(p)+1):
                yield p[:i] + l[0:1] + p[i:]
            
def lcm(a,b):
    '''Returns the least common multiple of a and b'''
    if a == 0 or b == 0:
        return 0
    return int((a*b) / gcd(a,b))

def kCombinations(l, k):
    '''Generator: generates all k-combinations of objects in the list l'''
    if k == 0:
        yield []
    else:
        for i in xrange(len(l)):
            for c in kCombinations(l[i+1:], k-1):
                yield c + [l[i]]

def partition(n, g):
    ''' Returns the number of ways to partions set of n 
    elements with a parition of size g'''
    if n == 1:
        return 1
    elif n == g:
        return 1
    elif g>n or g<=0:
        return 0
    else:
        sum = 0
        for i in range(g, n-g+1, 1):
            sum += partition(n-g, i)
        return sum

def numParitions(n):
    '''Returns the total number of ways to partition a set
    of n elements.'''
    sum = 0
    for i in range(1, n+1, 1):
        sum += partition(n,i)
    return sum


def genParitions(n):
    '''Generator: Non recursively generates all partitions on n indistiguishable objects.
    The next set of partitions (state) generated is based only on the previous state 
    generated, so only the previous state needs to be maintained.

    [Initial and Final Conditions]
    The generator is initialized by starting with n partitions of size 1 and terminates
    when it reaches one partition of size n.

    [Data Structures]
    Each way to partition (state) is represented as a list of integers. These integers
    are the size of the paritions and always sum to n. The next state is generated by
    examining this list and determining how many of each size partition there is.

    [Algorithm]
    Each new state is generated uniquely by modifying the current state in the following ways:
    
    [A] If there are 2 or more paritions of size 1, then merge any 2 partitions of size 1 into
        a single partition of size 2

    [B] If there are less than 2 paritions of size 1, then create a partition of the next
        largest size (larger than 2). To do this, accumulate a sum starting at all objects 
        in partitions of size 1. Then sum over all objects in partitions of size 2, etc until
        the total sum is greater than or equal to the size of partition currently being 
        sought after. In other words, if the sum (count of objects) is greater than or equal
        to a partition of size "i" where 1 <= i <= n, then there are enough objects to make 
        a new partition of size i.

        If the sum is greater than "i" (which means there will be extra objects left over after 
        "i" objects of the sum into a new i-partition) then new paritions of size 1 are created
        from the remaining objects and the algorithms continues. In this way a new parition of
        size n and 0 other partitions will be created (which is the terminating condition).
    '''
    lastPart = [1]*n
    yield lastPart

    while lastPart.count(n) < 1 :
        if (lastPart.count(1)-2) >= 0 :
            # number of 1's
            l = [1] * (lastPart.count(1)-2)

            #number of 2's
            l += [2] * (lastPart.count(2)+1)

            #handle the rest of the paritions
            for k in range(3, n, 1):
                l += [k] * (lastPart.count(k))
            lastPart = l
            yield lastPart			
        else:
            total  = lastPart.count(1)
            x = 2
            while total < x and x < n:
                total += lastPart.count(x)*x
                x +=1
            l = [x] * (lastPart.count(x) + 1)
            total -= x
            l += [1]*total
            for y in range(x+1, n, 1):
                l += [y] * (lastPart.count(y))
            lastPart = l
            yield lastPart	

def printIntPart( n ):
    '''Prints the output of each generation of the genParitions generator'''
    for i in genPartitions( n ):
        i.sort()
        print i

def numIsomorphismClasses( n ):
    '''Calculates the total number of isomorphism classes in the 
    set of graphs of n vertices. Uses the partition generator
    and Cycle Index polynomial Z.'''

    f = factorial( n )
    terms = 0

    #for each way to partition n objects, generate a monomial of Z	
    for p in genPartitions( n ):
        coef = 1
        monomial = 1
        for i in range( 1, n+1, 1 ):
            c = p.count(i)
            if( c > 0 ):
                coef *= int((factorial(c)*(pow(i,c))))
                monomial *= int(pow(n,c))
        terms += coef*monomial

    return int(terms/f)
			
		
